---
title: 笔记-反射
date: 2020-04-20 19:23:52
categories: 后端学习
tags:
- [反射]
- [动态代理]
---

施工中

<!-- more -->

# 反射

## 概述 

Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期
借助于反射相关的API取得任何类的内部信息，并能直接操作任意对象的内
部属性及方法。

## Class类

在Object类中定义了以下的方法，此方法将被所有子类继承。

```java
public final Class getClass()
```

以上的方法返回值的类型是一个Class类，此类是Java反射的源头。

### Class类的特点

- Class本身也是一个类
- Class 对象只能由系统建立对象
- 一个加载的类在 JVM 中只会有一个Class实例
- 一个Class对象对应的是一个加载到JVM中的一个`.class`文件
- 每个类的实例都会记得自己是由哪个 Class 实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象，才能进行后续的操作

### Class类的常用方法

- **static Class forName(String name)** ：返回指定类名 name 的 Class 对象
- **Object newInstance()**： 调用缺省构造函数，返回该Class对象的一个实例
- **getName()** ：返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称
- **Class getSuperClass()**： 返回当前Class对象的父类的Class对象
- **Class [] getInterfaces()**：获取当前Class对象的接口
- **ClassLoader getClassLoader()**：返回该类的类加载器
- **Constructor[] getConstructors()**：返回一个包含某些Constructor对象的数组
- **Field[] getDeclaredFields()**：返回Field对象的一个数组
- **Method getMethod(String name,Class … paramTypes)**：返回一个Method对象，此对象的形参类型为paramType

### 获取Class类的实例
- 前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高
```java
Class clazz = String.class;
```
- 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象
```java
Class clazz = “www.xxx.com”.getClass();
```
- 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
```java
Class clazz = Class.forName(“java.lang.String”);
```
- 其他方式
```java
ClassLoader cl = this.getClass().getClassLoader();
Class clazz4 = cl.loadClass(“类的全类名”);
```

## 反射调用构造方法

### 利用反射调用非私有的构造方法

```java
public class ReflectionTest {
    public static void main(String[] args) throws Exception {
        // ***反射调用非私有的构造方法***
        // 1.根据全类名获取对应的Class对象
        Class<?> clazz = Class.forName("reflection.Person");
        
        // 2.调用指定 参数结构 的构造器，生成Constructor的实例
        Constructor<?> con = clazz.getConstructor(String.class);
        
        // 3.通过Constructor的实例创建对应类的对象，并初始化类属性
        Person p1 = (Person)con.newInstance("张三");
        System.out.println(p1);// Person [name=张三, age=null]    
    }
}

class Person {
    private String name;
    private Integer age;
    
    public Person(String name) {
        this.name = name;
    }
	// getter、setter、toString省略
}
```

### 利用反射调用私有构造方法

```java
public class ReflectionTest {
    public static void main(String[] args) throws Exception {        
        // ***反射调用私有的构造方法***
        // 1.根据全类名获取对应的Class对象
        Class<?> clazz = Class.forName("reflection.Person");
        
        // 2.调用指定 参数结构 的构造器，生成Constructor的实例
        Constructor<?> con = clazz.getDeclaredConstructor(String.class,Integer.class);
        
        // 3.开启访问权限 con.setAccessible(true);
        con.setAccessible(true);
        
        // 4.通过Constructor的实例创建对应类的对象，并初始化类属性
        Person p2 = (Person)con.newInstance("李四",33);
        System.out.println(p2);// Person [name=李四, age=33]
    }
}

class Person {
    private String name;
    private Integer age;
    
    private Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
	// getter、setter、toString省略
}
```

## 反射调用普通方法

### 反射调用非私有的方法

```java
public class ReflectionTest {
    public static void main(String[] args) throws Exception {
        // ***反射调用非私有的方法***
        // 1.根据全类名获取对应的Class对象
        Class<?> clazz = Class.forName("reflection.Person");
        
        // 2. 创建运行时类的对象，此处调用了无参构造方法！！！
        Person p1 = (Person)clazz.newInstance();
        
        // 3.调用getMethod()方法，生成Method的实例
        // 参数1是方法名，参数2是方法的参数列表(.class)
        Method m1 = clazz.getMethod("eat", String.class);
        
        // 4.调用invoke()方法执行所选方法
        // 参数1为类的实例对象,即调用者，参数2为执行方法的实参
        // invoke()的返回值即为对应类中调用的方法的返回值。
        m1.invoke(p1, "Person");
    }
}


class Person {
    private String name;
    private Integer age;
    
    public void eat(String str) {
        System.out.println(str + "的默认方法eat()执行了");
    }
    
    public Person() {
        super();
    }
	// 省略getter、setter和toString方法
}
```

### 反射调用静态方法
```java
package reflection;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class ReflectionTest {
    public static void main(String[] args) throws Exceprion {    
        // ***反射调用静态方法***
        // 1.根据全类名获取对应的Class对象
        Class<?> clazz = Class.forName("reflection.Person");
        
        // 2. 创建运行时类的对象，此处调用无参构造方法！！！
        Person p1 = (Person)clazz.newInstance();
        
        // 3.调用getMethod()方法，生成Method实例
        // 参数1是方法名，参数2是方法的参数列表(.class)
        Method m2 = clazz.getDeclaredMethod("add", int.class,int.class);
        
        // 4.调用invoke()方法执行所选方法
        // 参数1为运行时类,即调用者，参数2为执行方法的实参
        // invoke()的返回值即为对应类中调用的方法的返回值。
        m2.invoke(Person.class, 1,2);
    }
}


class Person {
    private String name;
    private Integer age;
     
    public static int add(int a,int b) {
        System.out.println("Person的静态方法add()执行了，返回值为：" + (a+b));
        return a + b;
    }
       
    public Person() {
        super();
    }
	// 省略getter、setter和toString方法
}
```

### 反射调用私有方法

```java
package reflection;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class ReflectionTest {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        // ***反射调用私有方法***
        // 1.根据全类名获取对应的Class对象
        Class<?> clazz = Class.forName("reflection.Person");
        
        // 2. 创建运行时类的对象，此处调用无参构造方法！！！
        Person p1 = (Person)clazz.newInstance();
        
        // 3.调用getDeclaredMethod()方法，生成Method实例
        // 参数1是方法名，参数2是方法的参数列表(.class)
        Method m3 = clazz.getDeclaredMethod("drink", String.class);
        
        // 4.开启访问权限 m3.setAccessible(true);
        m3.setAccessible(true);
        
        // 5.调用invoke()方法执行所选方法
        // 参数1为类的实例对象,即调用者，参数2为执行方法的实参
        // invoke()的返回值即为对应类中调用的方法的返回值。
        m3.invoke(p1, "Person");
    }
}

class Person {
    private String name;
    private Integer age;
    
    private void drink(String str) {
        System.out.println(str + "中的私有方法drink()执行了");
    }
    
    public Person() {
        super();
    }
	// 省略getter、setter和toString方法
}
```

## 反射设置属性

### 反射设置非私有属性

```java
package reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class ReflectionTest02 {
    public static void main(String[] args) throws Exception{
        
        // ***反射设置非私有属性值***
        // 1.根据全类名创建运行时类
        Class<?> clazz = Class.forName("reflection.Animal");
        
        // 2.创建运行时类的对象,此处暴力反射，调用setAccessible(true)
        // 和getDeclaredConstructor()获取了Animal的私有无参构造方法，
        // 进而创建了运行时类的对象
        Constructor<?> d = clazz.getDeclaredConstructor();
        d.setAccessible(true);
        Object newInstance = d.newInstance();
        Animal a = (Animal) newInstance;
        
        // 3.调用getField()方法获取Field实例
        // 参数为指定的变量名/属性名
        Field f = clazz.getField("name");
        // 4.设置指定的属性值
        // 参数1为被设置属性的 对象 ，参数2为要设置的属性值
        f.set(a, "王五");
        // 5.获取**指定对象**的属性值
        System.out.println(f.get(a));
    }
}

class Animal {
    public String name;
    private int age;
    
    private Animal() {
        super();
    }

    private Animal(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
	
}
```

### 反射设置非私有属性

```java
package reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class ReflectionTest02 {
    public static void main(String[] args) throws Exception{
        
        // ***反射设置私有属性值***
        // 1.根据全类名创建运行时类
        Class<?> clazz = Class.forName("reflection.Animal");
        
        // 2.创建运行时类的对象,此处暴力反射，调用setAccessible(true)
        // 和getDeclaredConstructor()获取了Animal的私有无参构造方法，
        // 进而创建了运行时类的对象
        Constructor<?> d = clazz.getDeclaredConstructor();
        d.setAccessible(true);
        Object newInstance = d.newInstance();
        Animal a = (Animal) newInstance;
     
        // 3.调用getDeclaredField()方法获取Field实例
        // 参数为指定的变量名/属性名
        Field f = forName.getDeclaredField("age");
        // 4.开启开启访问权限 f.setAccessible(true);
        f.setAccessible(true);
        // 5.设置指定的属性值
        // 参数1为被设置属性的 对象 ，参数2为属性设置值
        f.set(a, 35);
        // 6.获取**指定对象**的属性值
        System.out.println(f.get(a));
    }
}

class Animal {
    public String name;
    private int age;
    
    
    private Animal() {
        super();
    }

    private Animal(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
	
}
```

## 动态代理



